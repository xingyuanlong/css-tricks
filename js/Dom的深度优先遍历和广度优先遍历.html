<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>深度遍历和广度遍历测试</title>
    <style type="text/css"></style>
  </head>
  <body>
    <div class="box">
      <ul class="menus">
        <li class="item1">
          <i class="item1-icon"></i><span class="item1-content">菜单1</span>
        </li>
        <li class="item2">
          <i class="item2-icon"></i><span class="item2-content">菜单2</span>
        </li>
        <li class="item3">
          <i class="item3-icon"></i><span class="item3-content">菜单3</span>
        </li>
      </ul>
    </div>
    <script>
      console.log("深度优先递归");
      let arr = [];
      DFTRecur(document.body, arr, function (item) {
        console.log(item);
      });
      console.log('arr:\t', arr);
      // console.log("深度优先非递归");
      // DFT(Array.from(document.body.children), function (item) {
      //   console.log(item);
      // });

      // console.log("广度优先递归");
      // BFTRec(document.body, []);

      // console.log("广度优先非递归");
      // BFT(Array.from(document.body.children));

      //深度优先遍历的递归写法
      function DFTRecur(root, stack, fVistor) {
        let b = false;
        console.log("stack:\n", stack);
        if (root != null) {
          stack.push(root);

          fVistor(root);

          var children = root.children;
          if (children) {
            for (var i = 0; i < children.length; i++) {
              b = DFTRecur(children[i], stack, fVistor);
              if (b) {
                break;
              }
            }
          }
          if (!b) {
            stack.pop();
          }
        }
        return b;
      }

      //深度优先遍历的非递归写法
      function DFT(root, fVistor) {
        fVistor = fVistor || console.log;
        if (root != null) {
          //兼容root为数组，且从前往后深度遍历
          var stack = [].concat(root).reverse();

          while (stack.length != 0) {
            var item = stack.pop();
            if (fVistor(item)) {
              break;
            }
            if (item.children) {
              stack.push(...Array.from(item.children).reverse());
            }
          }
        }
      }

      //广度优先遍历的递归写法
      function BFTRec(root, queue, fVistor) {
        fVistor = fVistor || console.log;
        if (root != null) {
          queue.push(root);
          if (fVistor(root)) {
            return;
          }
          BFTRec(root.nextElementSibling, queue, fVistor);
          root = queue.shift();
          BFTRec(root.firstElementChild, queue, fVistor);
        }
      }

      //广度优先遍历的非递归写法
      function BFT(root, fVistor) {
        fVistor = fVistor || console.log;
        if (root != null) {
          //兼容root为数组情况
          var queue = [].concat(root);
          while (queue.length != 0) {
            var item = queue.shift();
            if (fVistor(item)) {
              break;
            }
            if (item.children) {
              queue.push(...item.children);
            }
          }
        }
      }
    </script>
  </body>
</html>
