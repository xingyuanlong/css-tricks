<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>es5 创建对象</title>
</head>
<body>
    
    <script>
        let o,o1;
        const log =console.log;
        // 工厂模式
        function createPerson1(n,a) {
            let o =new Object();
            o.n=n;
            o.a=a;
            o.sayName=function (){
                log(o.n,this.n);
            }
            return o;
        }
        o=createPerson1('工厂模式',1);
        o.sayName();
        log(Object.getPrototypeOf(o))
        log(o instanceof createPerson1);
        // false 
        // 无法确定对象的类型

        // 构造函数模式
        function Person1 (n,a) {
            this.n=n;
            this.a=a;
            this.sayName=function (){
                log(this.n)
            }
            this.sayA=sayA;
        }
        o=new Person1('构造函数模式','构造函数模式=a');// 若此时不使用new, 内部的this 指向window
        // 创建Person 新实例的步骤:
        // 1. 创建一个新对象
        // 2. 将构造函数的作用域赋值给新对象(因此this指向这个对象)
        // 3. 执行构造函数中的代码
        // 4. 返回新对象
        o.sayName();
        log( o.constructor === Person1); 
        // true
        // 对象有constructor(构造函数)属性指向Person 
        log(o instanceof Object);
        log(o instanceof Person1);
        // true
        // 实例标识为一种特殊的类型

        // 任何函数只要通过new 操作符调用,都可以作为构造函数 (es6 箭头函数除外)

        // 构造函数的缺点: 每个方法都要在每个实例上重新创建一遍
        o1=new Person1('o1');
        log(o.sayName == o1.sayName);
        // 不同实例上同名函数不相等
        // 完成同样任务的函数 重复实例不是最优
        // 可以把函数定义移到外部
        function sayA(){
            log(this.a);
        }
        o.sayA();
        // 缺点: 都定义在全局 没有封装性

        // 原型模式
        // 每个函数都要prototype原型属性,指向一个对象,这个对象包含可以由特定类型的所有共享的属性和方法.
        // 让所有对象实例共享包含的属性和方法,即直接将信息添加到原型对象上
        function Person2(){

        }
        Person2.prototype.n='nnn';
        Person2.prototype.sayName=function(){
            log(this.n);
        }
        o=new Person2();
        log(Person2.prototype.constructor === Person2);
        // 创建新函数时,会为该函数创建一个prototype 属性, 指向原型对象
        // 默认情况下 原型对象都会自动获得一个constructor(构造函数)属性, 这个属性是一个指向prototype 属性所在的函数指针.
        // Person2.prototype.constructor === Person2
        // 原型对象默认只要constructor属性,其他属性从Object 继承来
        // es6 箭头函数没有原型对象

        // 调用构造函数创建的实例 内部含有一个属性 _proto_ 指向原型对象 (浏览器实现)
        log(o._proto_); // 浏览器控制台有效
        log(Person2.prototype == Object.getPrototypeOf(o));

        // 重写原型对象切断现有原型与任何之前已经存在的对象实例之间的联系,之前的对象依然引用之前的原型.
        // 原型模式缺点, 实例都要有自己属性和方法, 原型上定义引用类型会互相干扰

 

        // 组合使用构造函数和原型模式
        // 构造函数定义实例属性,原型用于定义方法和共享属性
        // 实例有自己特有的属性,又有共享的属性和方法,最大幅度节省内存,也最高效
        function Person3(n){
            this.n=n;
        }
        Person3.prototype.sayName=function(){
            log(this.n);
        }
        o=new Person3('组合使用构造函数和原型模式');
        o.sayName();
        // 推荐
     
   
     
        // 动态原型模式
        function Person4(n){
            this.n=n;
            if (typeof this.sayName != 'function'){
                log('Person4====');
                // 检查方法是否存在来 初始化原型, 仅初始化时执行
                Person4.prototype.sayName=function(){
                    log(this.n);
                }
            }
        }
        o=new Person4('动态原型模式');
        o.sayName();
        o1=new Person4('动态原型模式');
        o1.sayName();


        // 寄生构造函数模式
        function NewArr(){
            let v=new Array();
            v.push.apply(v,arguments);
            v.toNewString= function(){
                return this.join('|');
            }
            return v;
        }
        o=new NewArr(1,2,3,4);
        // 与工厂模式相比 使用new 来调用
        log(o.toNewString());
        // 不推荐使用, 无法确定原型
        log(o instanceof NewArr);// false



        // 稳妥构造函数模式
        // 没有公共属性,也不使用this 对象
        function Person5(n){
            let o=new Object();
            o.sayName=function (){
                log(n);
            }
            return o;
        }
        o=new Person5('稳妥构造函数模式');
        o.sayName();
        log(o instanceof Person5);// false
        // 不推荐使用, 无法确定原型
    </script>
</body>
</html>