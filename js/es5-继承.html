<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>es5 继承</title>
  </head>

  <body>
    <script>
      const log = console.log;
      let o;
      let o1;
      // 原型链
      // 利用原型让一个引用类型继承另一个引用类型的属性和方法.
      function SuperType1() {
        this.p = "SuperType1";
        this.c = [1];
      }
      SuperType1.prototype.getP = function () {
        return this.p;
      };

      function SubType1() {
        this.sp = "SubType1";
      }
      // 重写原型对象,
      SubType1.prototype = new SuperType1();
      SubType1.prototype.getSP = function () {
        return this.sp;
      };
      o = new SubType1();
      o1 = new SubType1();
      log(o.getSP());
      log(o.getP());
      log(o instanceof SubType1);
      log(o instanceof SuperType1);
      log("isPrototypeOf");
      log(SubType1.prototype.isPrototypeOf(o));
      log(SubType1.prototype.isPrototypeOf(o1));
      o.c.push(2);
      log(o.c);

      log(o1.c);

      // 问题: 1.不能向超类的构造函数传递参数
      //       2. 包含引用类型的原型修改会影响到其他实例

      // 借用构造函数
      function SuperType2(n) {
        this.p = [1, 2, 3];
        this.n = n;
      }

      function SubType2(n) {
        SuperType2.call(this, n);
      }

      o = new SubType2(1);
      o.p.push(4);
      log(o.p);
      o1 = new SubType2(2);
      log(o1.p);

      // 问题: 方法都要在构造函数中定义,函数复用无法谈起.

      // 组合继承
      // 原型链和借用构造函数结合在一起
      function SuperType3(n) {
        this.p = [1, 2, 3];
        this.n = n;
        log("twice");
      }
      SuperType3.prototype.sayN = function () {
        log(this.n);
      };

      function SubType3(n, a) {
        SuperType3.call(this, n);
        this.a = a;
      }
      SubType3.prototype = new SuperType3();
      SubType3.prototype.constructor = SubType3;
      SubType3.prototype.sayA = function () {
        log(this.a);
      };
      o = new SubType3("组合继承", "组合继承==");
      o.p.push(4);
      log(o.p);
      o.sayA();
      o1 = new SubType3("组合继承", " 组合继承---");
      log(o1.p);
      o1.sayA();
      log("isPrototypeOf");
      log(SubType3.prototype.isPrototypeOf(o));
      log(SubType3.prototype.isPrototypeOf(o1));
      // 常用

      // 原型式继承
      // 基于已有对象创建新对象
      function NewObject(o) {
        function F() {}
        F.prototype = o;
        return new F();
      }
      // Object.create();
      // 缺点: 包含引用类型的值,会互相影响

      // 寄生式继承
      function createObj(o) {
        let clone = NewObject(o);
        clone.sayN = function () {
          log("aaaa");
        };
        return clone;
      }
      o = createObj({
        a: 1,
      });
      o.sayN();
      log(o);
      // 缺点: 函数无法复用

      // 寄生组合式继承
      // 组合继承二次调用父类的构造函数
      // 借用构造函数来继承属性,通过原型链混成来继承方法
      // 不必为了指定子类型的原型而调用超类型的构造函数
      function inheritPrototype(subType, superType) {
        let prototype = NewObject(superType.prototype); // 创建对象
        prototype.constructor = superType; // 增强对象
        superType.prototype = prototype; // 指定对象
      }

      function SuperType4(n) {
        this.p = [1, 2, 3];
        this.n = n;
        log("once");
      }
      SuperType4.prototype.sayN = function () {
        log(this.n);
      };

      function SubType4(n, a) {
        SuperType4.call(this, n);
        this.a = a;
      }
      inheritPrototype(SubType4, SuperType4);
      SubType4.prototype.sayA = function () {
        log(this.a);
      };
      o = new SubType4("寄生组合式继承", "寄生组合式继承==");
      o.p.push(4);
      log(o.p);
      o.sayA();
      o1 = new SubType4("寄生组合式继承", " 寄生组合式继承---");
      log(o1.p);
      o1.sayA();
      log("isPrototypeOf");
      log(SubType4.prototype.isPrototypeOf(o));
      log(SubType4.prototype.isPrototypeOf(o1));
    </script>
  </body>
</html>
